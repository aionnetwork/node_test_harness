plugins {
    id 'java-library'
}

targetCompatibility = 10
sourceCompatibility = 10

sourceSets {
    main { 
        java.srcDirs = ['src']
        resources.srcDirs = ['src_resources']
    }
    test { 
        java.srcDirs = ['test']
        resources.srcDirs = ['test_resources']
    }
}

repositories {
    jcenter()
}

dependencies {
    api fileTree(dir: 'lib', include: ['*.jar'])
    api project(':TestHarness') 

    testImplementation 'junit:junit:4.12'
    testImplementation fileTree(dir: 'lib', include: ['*.jar'])
    testImplementation fileTree(dir: '../TestHarness/lib', include: ['*.jar'])
}

test {
	if ( project.hasProperty("skipCleanLogs") ) {
		systemProperty "skipCleanLogs", project.getProperty("skipCleanLogs")
	}

    // If 'sequential' is specified or if 'saturation' is specified we run the tests these ways.
    // However, the default way to run the tests is using the concurrent executor.
	if ( project.hasProperty("sequential") ) {
		exclude '**/integ/concurrent/ConcurrentSuite.class'
	} else if (project.hasProperty("saturation")) {
        	include '**/integ/saturation/*'
    	} else if (project.hasProperty("unsignedSaturation")) {
        	include '**/integ/unsignedSaturation/*'
    	} else {
        	include '**/integ/concurrent/ConcurrentSuite.class'
    	}

	if ( project.hasProperty("testNodes") ) {
		systemProperty "testNodes", project.getProperty("testNodes")
	}
}

build.dependsOn.remove('check')  // don't run tests on 'build' task
test.outputs.upToDateWhen {false} // make test target always run even if source didn't change
test { testResultsDirName = "${rootProject.projectDir}/report/FunctionalTests" }
